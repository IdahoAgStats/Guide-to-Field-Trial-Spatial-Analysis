# Applying Spatial Covariates {#ch4}


```{r message=FALSE, warning=FALSE}
library(agridat); library(dplyr); library(tidyr)
library(sp)

data("stroup.nin")

Nin <- stroup.nin %>% mutate(col.width = col * 1.2, 
                             row.length = row * 4.3) %>% 
  fill(rep, .direction = "up") %>%  arrange(col, row) 

Nin_na <- filter(Nin, !is.na(yield))

Nin_spatial <- Nin_na
coordinates(Nin_spatial) <- ~ col.width + row.length

```

Once spatial autocorrelation has been identified in field trials, the next logical step is to employ a modelling technique that will reduce the impact of spatial varition on the final estiamtes from the analysis.  

## Prep work

As a reminder, the first thing is to run a standard linear model. A common model specification for the randomised complete block design (RCBD) is to include cultivar as a fixed effect and block as a random effect. 

Below is the R code for RCBD analsysis of the NIN data set loaded in Section 3 \@ref(ch:ch3) that was found to have strong spatial correlation:

```{r message=FALSE, warning=FALSE}
library(nlme); library(emmeans)

nin.lme <- lme(yield ~ gen, random = ~1|rep,
              data = Nin,
              na.action = na.exclude)

# extract the least squares means for vareity
lme.preds <- as.data.frame(emmeans(nin.lme, "gen"))
```

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
library(spdep)
xy.rook <- cell2nb(nrow = max(Nin$row), ncol = max(Nin$col), type="rook") 
```

The variables "gen" refers to the cultivar or breeding line being trialled, and "rep" is the block, and the dependent variable, "yield" is grain yield. Basic exploratory analysis was conducted in Section 3 \@ref(ch:ch3). 

## Correlated Errors I: spatial distance 

**Gaussian Example**

In order to fit models using correlated error model, we will need to first obtain preliminary estimates of the nugget, sill and range: from fitting an empirical variogram. 

```{r}
library(gstat)
max_dist <- 0.6*max(dist(coordinates(Nin_spatial)))
resid.var1 <- variogram(yield ~ rep + gen, 
                        cutoff = max_dist,
                        width = max_dist/29, 
                        data = Nin_spatial)
nugget_start <- min(resid.var1$gamma)
``` 

In the previous section, an isotropic Gaussian function was identified as the best model for describing the decay of error correlations over distance.

```{r}
Nin.vgm <- vgm(model = "Gau", nugget = nugget_start) 
Nin.variofit <- fit.variogram(resid.var1, Nin.vgm)

nugget <- Nin.variofit$psill[1] 
range <- Nin.variofit$range[2] 
sill <- sum(Nin.variofit$psill) 
nugget.effect <-  nugget/sill
```

Create a correlated error structure using the **nlme** package.
```{r}
cor.gaus <- corSpatial(value = c(range, nugget.effect), 
                  form = ~ row.length + col.width, 
                  nugget = T, fixed = F,
                  type = "gaussian", 
                  metric = "euclidean")
```

Update the linear mixed model with the correlated error strucutre and inspect the results:
```{r}
nin.gaus <- update(nin.lme, corr = cor.gaus)

gaus.preds <- as.data.frame(emmeans(nin.gaus, "gen"))
```

Other models can be implemented quite similarily:

### Exponential

```{r}
rm(Nin.vgm, Nin.variofit, nugget, sill, range, nugget.effect)

Nin.vgm <- vgm(model = "Exp", nugget = nugget_start) 
Nin.variofit <- fit.variogram(resid.var1, Nin.vgm)

nugget <- Nin.variofit$psill[1] 
range <- Nin.variofit$range[2] 
sill <- sum(Nin.variofit$psill) 
nugget.effect <-  nugget/sill

cor.exp <- corSpatial(value = c(range, nugget.effect), 
                  form = ~ row.length + col.width, 
                  nugget = T, fixed = F,
                  type = "exponential", 
                  metric = "euclidean")

nin.exp <- update(nin.lme, corr = cor.exp)
exp.preds <- as.data.frame(emmeans(nin.exp, "gen"))
```

### Spherical

```{r}
rm(Nin.vgm, Nin.variofit, nugget, sill, range, nugget.effect)

Nin.vgm <- vgm(model = "Sph", nugget = nugget_start) 
Nin.variofit <- fit.variogram(resid.var1, Nin.vgm)

nugget <- Nin.variofit$psill[1] 
range <- Nin.variofit$range[2] 
sill <- sum(Nin.variofit$psill) 
nugget.effect <-  nugget/sill

cor.sph <- corSpatial(value = c(range, nugget.effect), 
                  form = ~ row.length + col.width, 
                  nugget = T, fixed = F,
                  type = "spherical", 
                  metric = "euclidean")

nin.sph <- update(nin.lme, corr = cor.sph)
gaus.sph <- as.data.frame(emmeans(nin.sph, "gen"))
```

### Power

```{r}
cor.pow <- corSpatial(form = ~ row.length + col.width, 
                  nugget = T, fixed = F,
                  type = "ratio", 
                  metric = "euclidean")

nin.pow <- update(nin.lme, corr = cor.pow)
pow.preds <- as.data.frame(emmeans(nin.pow, "gen"))
```

In the **nlme* package, there is also an option for a linear model in the `corSpatial()` function. However, if a linear trend is present without a range or sill, it is recommended that a linear trend be fitted to the data instead. 

The package **spaMM* implements additional correlation models such as MatÃ©rn, Cauchy and more. 

```{r message=FALSE, warning=FALSE}
library(spaMM)

rm(Nin.vgm, Nin.variofit, nugget, sill, range, nugget.effect)
Nin.vgm <- vgm(model = "Mat", nugget = nugget_start) 
Nin.variofit <- fit.variogram(resid.var1, Nin.vgm, fit.kappa = TRUE)
 
nugget <- Nin.variofit$psill[1] 
range <- Nin.variofit$range[2] 
sill <- sum(Nin.variofit$psill) 
nugget.effect <-  nugget/sill
kappa <- Nin.variofit$kappa[2]

cor.mat <- corMatern(value = c(1/range, kappa, nugget.effect), 
                  form = ~ row.length + col.width, 
                  nugget = T, fixed = F,
                  metric = "euclidean")
nin.mat <- update(nin.lme, corr = cor.mat)

mat.preds2 <- as.data.frame(emmeans(nin.pow, "gen"))
```


## Nearest Neighbor Approaches

At this time, there are not suitable options for running nearest neighbor analyses of variety trial data. Exising options in **spatialreg**, **spANOVA**, and **spaMM** are extraordinarily difficult to use, lack sufficient options for typical experimental design in variety trials and/or do not provide the desired output. 

## Splines

The package **SpATS**, spatial analysis for field trials
```{r}
library(SpATS)

# variables specifying row and column as factors are needed
Nin$colF <- Nin$R <- as.factor(Nin$col)
Nin$rowF <- Nin$C <- as.factor(Nin$row)

Nin.spline <- SpATS(response = "yield", 
                    spatial = ~ PSANOVA(col, row, nseg = c(10,20),
                                        degree = 3, pord = 2), 
                    genotype = "gen",  
                    random = ~ rep + rowF + colF, 
                    data = Nin, control = list(tolerance = 1e-03))

spline.preds <- predict(Nin.spline, which = "gen") %>% 
  select(gen, emmean = "predicted.values", SE = "standard.errors")
```

Examine spatial trends
```{r}
plot(Nin.spline)
```

### AR1xAR1

The package **Sommer** implements a version of the AR1xAR1 covariance structure. However, it does not estimate the parameter $\rho$. The user must specify the $\rho$ and that value is not optimized in the restricted maximum likelihood estimation. There may be another way to implement the AR1xAR1 spatial model using the package **TMB**. Both SAS and Asreml can implement a mixed model with this covariance structure.


```{r message=FALSE, warning=FALSE}
library(sommer) 

nin.ar1ar1 <- mmer(yield ~ gen,
                     random = ~ rep + 
                      vs(colF:rowF, Gu = kronecker(AR1(colF, rho=0.5), AR1(rowF, rho = 0.5), make.dimnames = TRUE)),
                   na.method.X = "include", na.method.Y = "exclude",
                   rcov = ~ units, data = Nin)

ar1ar1.preds <- predict(nin.ar1ar1, classify = 'gen')$predictions %>% 
  rename(emmean = "predicted.value.yield", SE = "standard.errors.yield")
```

